# Implementation Plan: Calm, Time-Boxed SRS Learning

**Branch**: `004-calm-srs-learning` | **Date**: 2026-01-29 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/004-calm-srs-learning/spec.md`

## Summary

Implement a calm, time-boxed vocabulary learning system on the existing Flutter mobile app. The feature uses FSRS (Free Spaced Repetition Scheduler) for optimal review scheduling, wraps it in a "Prompt → Response → Grade" interaction engine, and presents everything through a time-budgeted session UX that hides all backlog complexity. Core deliverables: session planner with priority scoring, FSRS-backed review engine, streak tracking, user preferences, and local-first persistence with resume-on-crash support.

## Technical Context

**Language/Version**: Dart 3.x (Flutter 3.x)
**Primary Dependencies**: `fsrs: ^2.0.1` (official FSRS Dart package), `drift` (SQLite ORM), `flutter_riverpod` (state management), `supabase_flutter` (backend sync)
**Storage**: SQLite via Drift (local, offline-first), PostgreSQL via Supabase (cloud sync)
**Testing**: `flutter_test`, `drift` test utilities
**Target Platform**: iOS + Android (Flutter), mobile-first
**Project Type**: Mobile (extends existing Flutter app at `mobile/`)
**Performance Goals**: Session startup < 500ms, item transitions < 100ms, 60fps UI
**Constraints**: Offline-capable (all SRS logic local), session timing via elapsed clock, local-first save after every item
**Scale/Scope**: Up to 10,000 vocabulary cards per user, daily sessions of 1-60 minutes

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Test-First | PASS | Unit tests for SRS scheduler, session planner, priority scorer. Widget tests for session UI screens. |
| II. Code Quality | PASS | Dart analyzer strict mode, dart format, no warnings. Follow existing CLAUDE.md conventions. |
| III. Observability | PASS | Structured logging for session events (start, complete, expire, resume). ReviewLog table captures all review telemetry. |
| IV. Simplicity (YAGNI) | PASS | MVP: 2 interaction modes only (Recognition + Recall). No optimizer, no adaptive mode selection. Use `fsrs` package directly. |
| V. Offline-First | PASS | All SRS logic runs locally. FSRS scheduler is pure Dart. Sessions persist to SQLite after every item. Sync via existing SyncOutbox pattern. |

**Post-Phase 1 Re-check**: All gates still pass. Data model uses existing Drift patterns. No new abstractions beyond what the feature requires.

## Project Structure

### Documentation (this feature)

```text
specs/004-calm-srs-learning/
├── plan.md              # This file
├── research.md          # FSRS algorithm research
├── data-model.md        # Database schema (Drift + Supabase)
├── quickstart.md        # Developer onboarding
├── contracts/           # Internal service contracts
│   ├── session-planner.md
│   └── srs-scheduler.md
└── tasks.md             # Generated by /speckit.tasks
```

### Source Code (repository root)

```text
mobile/lib/
├── data/
│   ├── database/
│   │   ├── tables.dart              # +LearningCards, ReviewLogs, LearningSessions,
│   │   │                            #  UserLearningPreferences, Streaks
│   │   └── database.dart            # Schema version 3 → 4
│   ├── repositories/
│   │   ├── learning_card_repository.dart
│   │   ├── review_log_repository.dart
│   │   ├── session_repository.dart
│   │   ├── streak_repository.dart
│   │   └── user_preferences_repository.dart
│   └── services/
│       └── sync_service.dart        # Extend for learning data
├── domain/
│   ├── services/
│   │   ├── srs_scheduler.dart       # FSRS wrapper
│   │   ├── session_planner.dart     # Priority scoring + time-boxing
│   │   └── telemetry_service.dart   # Rolling time-per-item estimation
│   └── models/
│       ├── session_plan.dart        # Session plan value object
│       └── priority_score.dart      # Priority calculation
├── features/
│   └── learn/
│       ├── screens/
│       │   ├── session_home_screen.dart     # "Start Session (X min)"
│       │   ├── session_screen.dart          # Active session with timer
│       │   ├── session_complete_screen.dart # "You're done" + bonus
│       │   └── learning_settings_screen.dart
│       ├── widgets/
│       │   ├── recognition_card.dart        # MCQ interaction
│       │   ├── recall_card.dart             # Self-grade interaction
│       │   ├── session_timer.dart           # Countdown timer
│       │   ├── session_progress_bar.dart    # Progress indicator
│       │   └── streak_indicator.dart        # Streak display
│       └── providers/
│           ├── session_providers.dart
│           ├── learning_preferences_providers.dart
│           └── streak_providers.dart
└── providers/
    └── learning_providers.dart      # Top-level SRS providers

mobile/test/
├── unit/
│   ├── services/
│   │   ├── srs_scheduler_test.dart
│   │   ├── session_planner_test.dart
│   │   └── telemetry_service_test.dart
│   └── repositories/
│       ├── learning_card_repository_test.dart
│       ├── session_repository_test.dart
│       └── streak_repository_test.dart
└── widgets/
    ├── recognition_card_test.dart
    ├── recall_card_test.dart
    └── session_screen_test.dart

supabase/migrations/
└── 2026MMDD000001_add_learning_tables.sql   # New tables + RLS
```

**Structure Decision**: Extends the existing mobile app architecture. New code follows the same `data/` (repositories, database) → `domain/` (services, models) → `features/` (screens, widgets, providers) pattern. No new top-level directories needed. The `learn` feature replaces the current "Coming soon" placeholder.

## Complexity Tracking

No constitution violations to justify. The design uses:
- One new dependency (`fsrs`) — well-justified as the core algorithm
- Existing patterns (Drift tables, Riverpod providers, SyncOutbox)
- No new abstractions beyond direct feature requirements
